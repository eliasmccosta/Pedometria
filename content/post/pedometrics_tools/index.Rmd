---
date: "2020-06-02"
diagram: true
image:
  caption: 'Image credit: [**Elias**](https://www.instagram.com/eliasmendescosta/)'
  focal_point: ""
  placement: 3
math: true
title: Ferramenta pedometricas
subtitle: 'Ferramenta pedometricas para análises de pedologia quantitativa'
summary: ''
bibliography: [references.bib]
link-citations: true 
csl: [geoderma-regional.csl]
authors:
- admin
categories:
  - R
  - Programação
tags:
  - MDS
  - Pedometria
nocite: | 
  @R-bookdown
---

```{r, eval=FALSE, echo=FALSE}
rmarkdown::render('index.Rmd', encoding = 'UTF-8'")
```

# Introdução
Nesse tutorial serão abordados através do Algoritmos para Pedologia Quantitativa (AQP em inglês) e pacotes auxiliares uma coleção de códigos, ideias, e plotes usando o software R [@2019]. Toda a teoria por trás de grande parte do código pode ser encontrada no artigo [*Algorithms for quantitative pedology: A toolkit for soil scientists*](https://www.sciencedirect.com/science/article/pii/S009830041200369X?via%3Dihub) [@Beaudette2013]. Além disso artigos disso alguns exemplos de aplicações das ferramentas podem se encontrados em @Pinheiro2016 e @Pinheiro2018. Para fins didáticos o tutorial foi dividido em três partes e os pacotes usados serão *soilDB*, que contem uma base de dados de solos para análises pedométricas, *AQP* que contem as principais ferramentas de pedologia quantitativa usadas no tutorial, *sharpshootR* que contem uma coelção de funções que dão suporte ao levantamento e exploração de dados de solos, *SP* um pacote que fornece classes e métodos para dados espaciais: pontos, linhas, polígonos e grades, *Hmisc* que contém muitas funções úteis para análise de dados, gráficos de alto nível, operações utilitárias, funções para calcular o tamanho de amostras, importar e manipular conjuntos de dados, imputar valores ausentes, criação avançada de tabelas, análise de cluster entre outras funções, *lattice* que é um sistema de visualização de dados de alto nível, poderoso e elegante, com ênfase em dados multivariados, *MASS* com funções e conjuntos de dados para apoiar Venables e Ripley, **Modern Applied Statistics with S** e *plyr* que contem um conjunto de ferramentas que resolve problemas tais como: Divisão, aplicação e combinação de dados. 

## Base de dados dos exercícios
Todos os dados usados nos exercícios ou são do pacote *AQP* ou são do pacote *soilDB*. Muitas das informações contidas nesse nesse tutorial foram extraídas do [projeto do AQP](http://ncss-tech.github.io/AQP/) 

```{r, warning=FALSE, message=FALSE}
# Carregando os pacotes no R
library(soilDB) 
library(aqp)  
library(sharpshootR) 
library(sp) 
library(Hmisc)
library(lattice)
library(MASS)
library(plyr)
```
# Parte I
Na parte I serão abordadas características das funções básicas do *AQP*, conceito de coleção de perfis de solos, **SoilProfileCollection**, e verificação da estrutura de dados na coleção, além de alguns plotes básicos.
A classe **SoilProfileCollection** foi projetada para simplificar o processo de trabalhar com a coleção de dados associados aos perfis de solo: dados em nível de local (site), dados em nível de horizonte, dados espaciais, dados de horizontes de diagnósticos, metadados, etc. Os exemplos listados abaixo devem ser copiados/colados deste documento e executados de forma interativa em R. Lembrando que antes de execultar você deve instalar e carregar todas as bibliotécas (pacotes) mencionados. 

## Criação de Objetos
Os objetos **SoilProfileCollection** geralmente são criados pela através de objetos *data.frame* (tabelas retangulares de dados) que contêm pelo menos três colunas essenciais:
- Uma coluna de identificação que identifica exclusivamente grupos de horizontes (por exemplo, *pedons*)
- Limites superiores do horizonte
- Limites inferiores do horizonte
O *data.frame* deve ser pré-classificado de acordo com o ID do perfil e o limite superior do horizonte. A notação de fórmula é usada para definir as colunas usadas para promover um objeto *data.frame*.
```{r, warning=FALSE, message=FALSE}
# Carregando dados de solos
# upgrade para SoilProfileCollection
# 'id' é o nome da coluna que contém o ID do perfil
# 'top' é o nome da coluna que contém os limites superiores do horizonte
# 'bottom' é o nome da coluna que contém os limites inferiores do horizonte
data(sp1) # Conjunto de dados sp1 do pacote AQP (data.frame)
aqp::depths(sp1) <- id ~ top + bottom 
aqp::site(sp1) <- ~ group 
```

## Acessando, configurando e substituindo dados
As funções de acesar são usadas para extrair componentes específicos dos objetos **SoilProfileCollection**.
```{r, warning=FALSE, message=FALSE}
# Métodos para inpensão dos objetos
idname (sp1) # auto-explicativo
horizonDepths(sp1) # auto-explicativo
depth_units(sp1) # defaults 'cm'
metadata(sp1) # 
profile_id(sp1) # vector com IDs dos perfis
horizonNames(sp1) # coluna com osnomes dos dados dos horizontes
siteNames(sp1) # coluna com os nomes do dados dos locais (site data)
length(sp1) # número de perfis na coleção
nrow(sp1) # número de horizontes na coleção
names(sp1) # nomes de colunas dos dados do site e do horizonte, concatenados em um único vetor
min(sp1) # profundidade de perfil mais raso da coleção
max(sp1) # profundidade de perfil mais profundo da coleção
```

## Dados do horizonte e do site (local)
Normalmente, os dados do horizonte e do site são os componentes mais importantes dos objetos SoilProfileCollection. Ambos são armazenados internamente como objetos data.frame; com uma ou mais linhas (por ID do perfil) na tabela do horizonte e uma linha (por ID do perfil) na tabela do site. As colunas de qualquer tabela podem ser acessadas com a notação *$*. Novos dados podem ser atribuídos a qualquer tabela da mesma maneira, desde que o comprimento dos novos dados seja:
- Mesmo tamanho que o número de perfis na coleção (o destino é a tabela de sites).
- Mesmo comprimento que o número de horizontes na coleção (o destino é a tabela do horizonte). 

## Plotando **SoilProfileCollection**
O método *plot()* para objetos **SoilProfileCollection** gera esboços de perfis na coleção com base nos limites dos horizontes, alinhados verticalmente a uma sequência inteira de 1 ao número de perfis. Os nomes dos horizontes são extraídos automaticamente de um nome de atributo no nível do horizonte (se presente) ou por meio de um atributo alternativo fornecido como argumento: *name = 'nomedacoula'*. As cores do horizonte são geradas automaticamente a partir do atributo no nível do horizonte *soil_color*, ou qualquer outro atributo da descrição de cor compatível com R, fornecido como argumento: *color = 'nomedacoula'*. Essa função é altamente personalizável; portanto, é prudente consultar a ajuda *(plotSPC)* de tempos em tempos. As cores do solo na notação Munsell podem ser convertidas em cores compatíveis com R via *munsell2rgb()*.

```{r, warning=FALSE, message=FALSE}
data(sp4) # Conjunto de dados sp4 do pacote AQP (data.frame)
aqp::depths(sp4) <- id ~ top + bottom 
# Atribuição de novos dados a atributos existentes ou novos
sp4$elevation <- rnorm(n=length(sp4), mean=1000, sd=150) # no nível do site, com base no comprimento dos dados atribuídos
sp4$thickness <- sp4$bottom - sp4$top # nível do horizonte
# Extração de atributos específicos por nome
sp4$clay # Vetor de conteúdo de argila (dados do horizonte)
```

Os dados do horizonte e do local (site) também podem ser modificados por extração para um data.frame, seguidos pela substituição (dados do horizonte) ou junção (dados do site). Observe que, embora essa abordagem ofereça a maior flexibilidade, ela também é a mais perigosa - a substituição dos dados do horizonte por novos dados que não estão exatamente de acordo com a classificação original pode corromper seu **SoilProfileCollection**.
```{r, warning=FALSE, message=FALSE}
# extrair dados os horizontes para o data.frame
h <- horizons(sp4)
# Adicionar uma nova coluna e salvar de volta no objeto
h$random.numbers <- rnorm(n=nrow(h), mean=0, sd=1)
# repor dados originais dos horizontes com versão modificada
#!a ordem das linhas não deve ser alterada!
horizons(sp4) <- h
# extrair dados do site para o data.frame
s <- site(sp4)
# Adicionar um grupo para o site fake
s$group <- factor(rep(c('A', 'B'), length.out=nrow(s)))
# junte novos dados do site com dados anteriores: os dados antigos não são substituídos
site(sp4) <- s
# Verificar
sp4
```

```{r, warning=FALSE, message=FALSE}
# Fazendo um plot simples
plot(sp4, name='name')
# title, note line argument:
title('Perfis de Solo', line=1, cex.main=0.75)
# profiles are centered at integers, from 1 to length(obj)
axis(1, line=0, at=1:15, cex.axis=0.75, font=4, col='blue', col.axis='blue', lwd=2)
mtext('Perfis', side=1, line=2, font=4, col='blue')
# y-axis is based on profile depths
axis(2, line=-1, at=pretty(1:max(sp4)), cex.axis=0.75, font=4, las=1, col='blue', col.axis='blue', lwd=2)
mtext('Profundidade', side=2, line=1, font=4, col='blue')

# plot com separação de grupos
aqp::groupedProfilePlot(sp4, groups='group', max.depth=240, group.name.offset = -5, id.style='side')
# Esboços Temáticos

sp4$clay # 
par(mar=c(1,1,3,1)) # tighter figure margins
plot(sp4, name='name', color='clay',cex.names=0.5,cex.id=0.5, id.style='top',col.legend.cex=1,family="serif", col.label='Argila', )

sp4$Ca # 
par(mar=c(1,1,3,1)) # tighter figure margins
plot(sp4, name='name', color='Ca',cex.names=0.5,cex.id=0.5, id.style='top',col.legend.cex=1,
     col.label='Ca', family="serif")

sp4$name # 
par(mar=c(2,2,3,2)) # tighter figure margins
plot(sp4, name='name', color='name', col.palette=RColorBrewer::brewer.pal(9, 'Set1'), col.label='Nomes do Horizontes', 
     cex.names=0.5)
###############
### Boxplot ###
# Aqui usaremos o conjunto sp1
sp1$name1 <- generalize.hz(sp1$name, 
                           new=c('A','AB', 'BA','B','BC', 'C', 'E', 'AE', 'O', 'H', 'R', '2C', '3C', '3B', '3A'), 
                           pat=c('^A','^AB','^BA','^B','^BC','^C', '^E', '^AE', '^O', '^H', '^R', '^2C', '^3C','^3B', '^3A' ))

# compute horizon mid-points 
sp1$mid <- with(horizons(sp1), (top+ bottom)/2)
# sort horizon designation by group-wise median values 
hz.designation.by.median.depths <- names(sort(tapply(sp1$mid, sp1$name1, median)))
# plot the distribution of horizon mid-points by designation 
bwplot(mid ~ factor(name, levels=hz.designation.by.median.depths),
       data=horizons(sp1),       
       ylim=c(200, 0), ylab='Profundidade do ponto médio do horizonte (cm)',       
       scales=list(y=list(tick.number=10)),       
       panel= function ( ... ) {
         panel.abline(h=seq(0, 180, by=10), v=1:length(hz.designation.by.median.depths), col=grey(0.8), lty=3)    
         panel.bwplot( ... ) })
bwplot(prop~ factor(name1, levels=hz.designation.by.median.depths),
       data=horizons(sp1),       
       ylab='Profundidade',       
       scales=list(y=list(tick.number=10)),       
       panel= function ( ... ) {  
         panel.abline(h=seq(0, 600, by=50), v=1:length(hz.designation.by.median.depths), col=grey(0.8), lty=3)  
         panel.bwplot( ... ) })
```

### Se você chegou até aqui muito bem !!!! 👏👏👏

# Referências
